package service

import (
	"encoding/json"
	"gorm.io/gorm"
	"strconv"
	"time"
	"web_penetration/internal/model"
)

// 漏洞管理器
type VulnerabilityManager struct {
	db *gorm.DB
}

// 创建漏洞记录
func (m *VulnerabilityManager) CreateVulnerability(vuln *model.Vulnerability) error {
	vuln.FoundTime = time.Now()
	vuln.Status = "pending"
	return m.db.Create(vuln).Error
}

// 更新漏洞状态
func (m *VulnerabilityManager) UpdateStatus(id uint, status string, handlerID uint) error {
	updates := map[string]interface{}{
		"status":     status,
		"handled_by": handlerID,
	}

	if status == "fixed" {
		updates["fixed_time"] = time.Now()
	}

	return m.db.Model(&model.Vulnerability{}).Where("id = ?", id).Updates(updates).Error
}

// 验证漏洞
func (m *VulnerabilityManager) VerifyVulnerability(id uint) error {
	// TODO: 实现漏洞验证逻辑
	return m.db.Model(&model.Vulnerability{}).Where("id = ?", id).
		Updates(map[string]interface{}{
			"verify_time": time.Now(),
			"status":      "confirmed",
		}).Error
}

// 获取任务漏洞统计
func (m *VulnerabilityManager) GetTaskStats(taskID uint) (*model.VulnStats, error) {
	var stats model.VulnStats
	stats.TaskID = strconv.Itoa(int(taskID))
	stats.UpdateTime = time.Now()

	// 统计总数
	var totalVulns int64
	if err := m.db.Model(&model.Vulnerability{}).
		Where("task_id = ?", taskID).
		Count(&totalVulns).Error; err != nil {
		return nil, err
	}
	stats.TotalVulns = int(totalVulns)

	// 按严重程度统计
	severityStats := make(map[string]int)
	if err := m.db.Model(&model.Vulnerability{}).
		Where("task_id = ?", taskID).
		Group("severity").
		Select("severity, count(*) as count").
		Scan(&severityStats).Error; err != nil {
		return nil, err
	}

	stats.HighVulns = severityStats["high"]
	stats.MediumVulns = severityStats["medium"]
	stats.LowVulns = severityStats["low"]

	// 按状态统计
	statusStats := make(map[string]int)
	if err := m.db.Model(&model.Vulnerability{}).
		Where("task_id = ?", taskID).
		Group("status").
		Select("status, count(*) as count").
		Scan(&statusStats).Error; err != nil {
		return nil, err
	}

	stats.FixedVulns = statusStats["fixed"]
	stats.PendingVulns = statusStats["pending"]

	return &stats, nil
}

// 获取漏洞列表
func (m *VulnerabilityManager) GetVulnerabilities(taskID uint, filters map[string]interface{}) ([]*model.Vulnerability, error) {
	var vulns []*model.Vulnerability
	query := m.db.Where("task_id = ?", taskID)

	// 应用过滤条件
	for key, value := range filters {
		query = query.Where(key+" = ?", value)
	}

	if err := query.Find(&vulns).Error; err != nil {
		return nil, err
	}

	return vulns, nil
}

// 添加漏洞证据
func (m *VulnerabilityManager) AddEvidence(vulnID uint, evidence *model.VulnEvidence) error {
	evidenceJSON, err := json.Marshal(evidence)
	if err != nil {
		return err
	}

	return m.db.Model(&model.Vulnerability{}).
		Where("id = ?", vulnID).
		Update("evidence", string(evidenceJSON)).Error
}

// 获取漏洞详情
func (m *VulnerabilityManager) GetVulnerabilityDetail(id uint) (*model.Vulnerability, error) {
	var vuln model.Vulnerability
	if err := m.db.First(&vuln, id).Error; err != nil {
		return nil, err
	}
	return &vuln, nil
}

// 批量更新漏洞
func (m *VulnerabilityManager) BatchUpdateStatus(ids []uint, status string, handlerID uint) error {
	return m.db.Model(&model.Vulnerability{}).
		Where("id IN ?", ids).
		Updates(map[string]interface{}{
			"status":     status,
			"handled_by": handlerID,
			"fixed_time": time.Now(),
		}).Error
}
